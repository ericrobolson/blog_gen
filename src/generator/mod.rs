use crate::{
    html::{element, CssLink, Html, HtmlElement, Metadata, Page, Stylesheet},
    parser::Css,
    Context, IntermediateRepresentation, Item, Location, Res,
};
use std::{fs, sync::Arc};

const ASSETS: &'static str = "assets";

pub fn execute(ir: Vec<Item<IntermediateRepresentation>>, context: Arc<Context>) -> Vec<Res<()>> {
    // Clear output directory
    match fs::remove_dir_all(&context.output.to_string()) {
        Ok(_) => {}
        Err(e) => match e.kind() {
            std::io::ErrorKind::NotFound => {
                // nothing to do here.
            }
            _ => {
                return vec![Res::Error {
                    location: Some(Location {
                        column: 0,
                        file: String::default(),
                        line: 0,
                        path: context.output.to_string(),
                    }),
                    msg: format!("{:?}", e.kind()),
                }]
            }
        },
    }

    // Create new output directory
    let output_dir = context.output.to_string();
    match make_dir(&output_dir) {
        Ok(_) => {}
        Err(e) => return e,
    }

    // Create assets directory
    match make_dir(&format!("{}{}", output_dir, ASSETS)) {
        Ok(_) => {}
        Err(e) => return e,
    }

    // Create any autogenerated files
    let ir = {
        let mut ir = ir;

        let stylesheet = Stylesheet::new(&context);

        let css = IntermediateRepresentation::Css(Css {
            contents: stylesheet.to_html().into_bytes(),
            file_name: "styles.css".into(),
        });

        ir.push(Item {
            item: css,
            location: None,
        });

        ir
    };

    // Create all files
    generate_all(ir, &context)
}

#[allow(unreachable_code)]
fn generate_all(ir: Vec<Item<IntermediateRepresentation>>, context: &Arc<Context>) -> Vec<Res<()>> {
    #[cfg(feature = "multithread")]
    {
        use rayon::prelude::*;
        return ir
            .par_iter()
            .map(|item| generate(item, context.clone()))
            .collect();
    }

    ir.iter()
        .map(|item| generate(item, context.clone()))
        .collect()
}

fn generate(ir: &Item<IntermediateRepresentation>, context: Arc<Context>) -> Res<()> {
    let output_dir = context.output.to_string();
    let path;
    let contents;

    let css_link: CssLink = format!("{}/{}", ASSETS, "styles.css").into();

    match &ir.item {
        IntermediateRepresentation::Css(css) => {
            path = format!("{}assets/{}", output_dir, css.file_name);
            contents = css.contents.clone();
        }
        IntermediateRepresentation::Img(img) => {
            path = format!("{}assets/{}", output_dir, img.file_name);
            contents = img.contents.clone();
        }
        IntermediateRepresentation::Md(md) => {
            path = format!("{}{}", output_dir, md.html_file_name.to_str());

            let page = Page {
                content: md.contents.item.to_element(),
                css: css_link,
                file_name: md.html_file_name.to_str().to_string(),
                metadata: Metadata {
                    author: context.config.author.clone(),
                    keywords: md.keywords.clone(),
                    summary: md.summary.clone(),
                },
                title: md.display_title.clone(),
            };

            contents = page.to_html().as_bytes().to_vec();
        }
        IntermediateRepresentation::Page(page) => {
            path = format!("{}{}", output_dir, page.file_name);

            let content = {
                let top_nav = element::top_nav(context.links.clone());

                element::div(vec![page.contents.item.to_element(), top_nav])
            };

            let page = Page {
                content,
                css: css_link,
                file_name: page.file_name.clone(),
                metadata: Metadata {
                    author: context.config.author.clone(),
                    keywords: page.keywords.clone(),
                    summary: page.summary.clone(),
                },
                title: page.title.clone(),
            };

            contents = page.to_html().as_bytes().to_vec();
        }
    }

    match fs::write(path, contents) {
        Ok(_) => Res::Ok(Item {
            item: (),
            location: None,
        }),
        Err(e) => Res::Error {
            msg: format!("{:#?}", e),
            location: ir.location.clone(),
        },
    }
}

fn make_dir(path: &String) -> Result<(), Vec<Res<()>>> {
    match fs::create_dir(&path) {
        Ok(_) => Ok(()),
        Err(e) => {
            return Err(vec![Res::Error {
                location: Some(Location {
                    column: 0,
                    file: String::default(),
                    line: 0,
                    path: path.clone(),
                }),
                msg: format!("{:?}", e.kind()),
            }])
        }
    }
}
